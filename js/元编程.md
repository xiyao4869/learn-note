##### new.target

```javascript
class Parent {
  constructor() {
    if (new.target === Parent) {
      console.log('Parent instantiated');
    } else {
      console.log('A child instantiated');
    }
  }
}
class Child extends Parent {}
var a = new Parent();
// Parent instantiated
var b = new Child();
// A child instantiated
```

##### Symbol.iterator

```javascript
var arr = [4, 5, 6, 7, 8, 9];

arr[Symbol.iterator] = function*() {
  var idx = 1;
  do {
    yield this[idx];
  } while ((idx += 2) < this.length);
};
for (var v of arr) {
  console.log(v);
}
// 5 7 9
```

##### Symbol.toStringTag 、 Symbol.hasInstance

```javascript
function Foo(greeting) {
  this.greeting = greeting;
}

Foo.prototype[Symbol.toStringTag] = 'Foo';

// Symbol.hasInstance 必须使用 Object.defineProperty(..)， 因为Function.prototype 上默认的那一个是writable: false(不可写的)
Object.defineProperty(Foo, Symbol.hasInstance, {
  value: function(inst) {
    return inst.greeting == 'hello';
  }
});

var a = new Foo('hello'),
  b = new Foo('world');

b[Symbol.toStringTag] = 'cool';
a.toString(); // [object Foo]
String(b); // [object cool]
a instanceof Foo; // true
b instanceof Foo; // false
```

##### Symbol.species

这个符号控制要生成新实例时，类的内置方法使用哪一个构造器。

##### Symbol.toPrimitive

```javascript
var arr = [1, 2, 3, 4, 5];
arr + 10; // 1,2,3,4,510
arr[Symbol.toPrimitive] = function(hint) {
  if (hint == 'default' || hint == 'number') {
    // 求所有数字之和
    return this.reduce(function(acc, curr) {
      return acc + curr;
    }, 0);
  } else if (hint == 'string') {
    return 'hello';
  }
};
arr + 10; // 25
String(arr) + ' world'; // 'hello world'
```

##### Symbol.isConcatSpreadable

```javascript
var a = [1, 2, 3],
  b = [4, 5, 6];
b[Symbol.isConcatSpreadable] = false;
[].concat(a, b); // [1,2,3,[4,5,6]]
```

##### Proxy

```javascript
var obj = { a: 1 },
  handlers = {
    get(target, key, context) {
      // 注意:target === obj,
      // context === pobj
      console.log('accessing: ', key);
      return Reflect.get(target, key, context);
    }
  },
  pobj = new Proxy(obj, handlers);
obj.a; // 1
pobj.a;
// accessing: a
// 1

==============  Proxy.revocable  ==============

// 可取消代理  Proxy.revocable
var obj = { a: 1 },
  handlers = {
    get(target, key, context) {
      // 注意:target === obj,
      // context === pobj
      console.log('accessing: ', key);
      return target[key];
    }
  },
  { proxy: pobj, revoke: prevoke } = Proxy.revocable(obj, handlers);
pobj.a;
// accessing: a
// 1
// 然后:
prevoke();
pobj.a;
// TypeError
```
